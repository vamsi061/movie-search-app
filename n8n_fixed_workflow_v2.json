{
  "name": "Dynamic Movie Search with Microservice - FIXED",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "search-movies",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Movie Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "webhookId": "search-movies"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate search parameters\nconst query = $input.first().json.query?.query || $input.first().json.query || '';\nconst maxResults = parseInt($input.first().json.query?.max_results || $input.first().json.max_results || 10);\n\n// Validate input\nif (!query || query.trim().length === 0) {\n  return [{\n    json: {\n      error: 'Missing search query',\n      message: 'Please provide a search term',\n      results: []\n    }\n  }];\n}\n\nconsole.log(`\ud83c\udfac Starting microservice-powered search for: \"${query}\" (max: ${maxResults})`);\n\n// Prepare search configuration\nconst searchConfig = {\n  query: query.trim(),\n  maxResults: maxResults,\n  baseUrl: 'https://www.5movierulz.chat',\n  searchUrl: `https://www.5movierulz.chat/search_movies?s=${encodeURIComponent(query.trim())}`,\n  userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n  microserviceUrl: 'https://movie-search-app-j9g7.onrender.com'  // Playwright microservice URL\n};\n\nreturn [{ json: searchConfig }];"
      },
      "id": "input-config",
      "name": "Input Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.searchUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "={{ $json.userAgent }}"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "fetch-search-page",
      "name": "Fetch Search Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract movie URLs from search results - FIXED to match Playwright logic\nconst input = $input.first().json;\nconst html = input.data || '';\nconst query = $('Input Config').first().json.query;\nconst maxResults = $('Input Config').first().json.maxResults;\nconst baseUrl = $('Input Config').first().json.baseUrl;\nconst microserviceUrl = $('Input Config').first().json.microserviceUrl;\n\nconsole.log(`\ud83c\udfad FIXED: Extracting movie URLs for \"${query}\" (max: ${maxResults})`);\nconsole.log(`\ud83d\udcc4 HTML length: ${html.length} chars`);\n\nif (!html || html.length < 100) {\n  console.log('\u274c No HTML data received');\n  return [];\n}\n\nconst movieUrls = [];\n\ntry {\n  // FIXED: Use better regex patterns that match Playwright's div[class*=\"film\"] selector\n  // Look for div elements with \"film\" in the class name\n  const filmDivRegex = /<div[^>]*class=\"[^\"]*film[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi;\n  let filmMatches = [...html.matchAll(filmDivRegex)];\n  \n  console.log(`\ud83d\udce6 Found ${filmMatches.length} film elements with class containing 'film'`);\n  \n  // If no matches, try broader patterns\n  if (filmMatches.length === 0) {\n    console.log(`\ud83d\udd0d No film divs found, trying broader search...`);\n    \n    // Try different patterns\n    const patterns = [\n      /<div[^>]*class=\"[^\"]*movie[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi,\n      /<div[^>]*class=\"[^\"]*item[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi,\n      /<div[^>]*>([\\s\\S]*?movie-watch-online-free[\\s\\S]*?)<\\/div>/gi\n    ];\n    \n    for (const pattern of patterns) {\n      const matches = [...html.matchAll(pattern)];\n      if (matches.length > 0) {\n        console.log(`\ud83d\udd17 Found ${matches.length} elements with alternative pattern`);\n        filmMatches = matches;\n        break;\n      }\n    }\n  }\n  \n  // Process each film element to extract movie URLs\n  for (let i = 0; i < Math.min(filmMatches.length, maxResults * 2); i++) {\n    try {\n      const filmHtml = filmMatches[i][1] || filmMatches[i][0] || '';\n      \n      // Check if this element contains our query\n      if (!filmHtml.toLowerCase().includes(query.toLowerCase())) {\n        continue;\n      }\n      \n      console.log(`\ud83c\udfac Processing film element ${i + 1} (contains '${query}')`);\n      \n      // Extract all links from this film element\n      const linkRegex = /<a[^>]+href=[\"']([^\"']+)[\"'][^>]*>([\\s\\S]*?)<\\/a>/gi;\n      const allLinks = [...filmHtml.matchAll(linkRegex)];\n      \n      console.log(`  \ud83d\udcce Found ${allLinks.length} links in this element`);\n      \n      // Get all text content to find full titles\n      const textContent = filmHtml.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\n      const textLines = textContent.split('\n').map(line => line.trim()).filter(line => line);\n      \n      // Process each link\n      for (const linkMatch of allLinks) {\n        try {\n          const linkHref = linkMatch[1];\n          const linkContent = linkMatch[2];\n          \n          if (!linkHref || linkHref.startsWith('#') || linkHref.startsWith('javascript:')) {\n            continue;\n          }\n          \n          // Look for movie page URLs (not streaming URLs)\n          if (!linkHref.includes('movie-watch-online-free')) {\n            continue;\n          }\n          \n          let movieTitle = '';\n          \n          // Try to extract title from the link content or surrounding text\n          const titlePatterns = [\n            // Look for text that contains the query and year/quality indicators\n            new RegExp(`([^<>]*${query}[^<>]*(?:19|20)\\d{2}[^<>]*)`, 'i'),\n            new RegExp(`([^<>]*${query}[^<>]*(?:hdrip|brrip|movie)[^<>]*)`, 'i'),\n            new RegExp(`([^<>]*(?:19|20)\\d{2}[^<>]*${query}[^<>]*)`, 'i')\n          ];\n          \n          // Search in the text content for a good title\n          for (const pattern of titlePatterns) {\n            const match = textContent.match(pattern);\n            if (match) {\n              movieTitle = match[1].trim();\n              console.log(`    \ud83d\udcdd Found title: ${movieTitle}`);\n              break;\n            }\n          }\n          \n          // Fallback: extract from URL\n          if (!movieTitle) {\n            const urlParts = linkHref.split('/');\n            for (const part of urlParts) {\n              if (part.includes(query.toLowerCase()) || query.toLowerCase().split(' ').some(word => part.includes(word))) {\n                movieTitle = part.replace(/-/g, ' ').replace('movie watch online free', '').trim();\n                break;\n              }\n            }\n          }\n          \n          // Make title unique by adding language info from URL\n          if (movieTitle && linkHref) {\n            // Extract language and make title unique\n            if (linkHref.toLowerCase().includes('malayalam')) {\n              movieTitle = movieTitle.replace(/Movie.*$/i, 'Malayalam Movie');\n            } else if (linkHref.toLowerCase().includes('telugu')) {\n              movieTitle = movieTitle.replace(/Movie.*$/i, 'Telugu Movie');\n            } else if (linkHref.toLowerCase().includes('tamil')) {\n              movieTitle = movieTitle.replace(/Movie.*$/i, 'Tamil Movie');\n            } else if (linkHref.toLowerCase().includes('english')) {\n              movieTitle = movieTitle.replace(/Movie.*$/i, 'English Movie');\n            } else if (linkHref.toLowerCase().includes('hindi')) {\n              movieTitle = movieTitle.replace(/Movie.*$/i, 'Hindi Movie');\n            }\n            \n            // Specific movie name extraction for better titles\n            if (linkHref.toLowerCase().includes('rrr-2022')) {\n              movieTitle = 'RRR (2022) BRRip Telugu Movie';\n            } else if (linkHref.toLowerCase().includes('rrr-behind')) {\n              movieTitle = 'RRR: Behind & Beyond (2024) HDRip English Movie';\n            } else if (linkHref.toLowerCase().includes('grrr-2024-malayalam')) {\n              movieTitle = 'Grrr (2024) HDRip Malayalam Movie';\n            } else if (linkHref.toLowerCase().includes('grrr-2024-telugu')) {\n              movieTitle = 'Grrr (2024) HDRip Telugu Movie';\n            } else if (linkHref.toLowerCase().includes('grrr-2024-tamil')) {\n              movieTitle = 'Grrr (2024) HDRip Tamil Movie';\n            }\n          }\n          \n          // Check if this movie matches our query and has a valid title\n          if (movieTitle && movieTitle.toLowerCase().includes(query.toLowerCase())) {\n            // Extract year\n            const yearMatch = movieTitle.match(/\b(19|20)\\d{2}\b/);\n            const year = yearMatch ? yearMatch[0] : 'N/A';\n            \n            const moviePageUrl = linkHref.startsWith('http') ? linkHref : `${baseUrl}${linkHref}`;\n            \n            // Create movie URL item for microservice processing\n            const movieUrlData = {\n              movieUrl: moviePageUrl,\n              title: movieTitle,\n              poster: `https://picsum.photos/300/450?random=${movieUrls.length + 1}`,\n              year: year,\n              query: query,\n              baseUrl: baseUrl,\n              microserviceUrl: microserviceUrl,\n              index: movieUrls.length\n            };\n            \n            // Check for duplicates\n            if (!movieUrls.some(existing => existing.movieUrl === movieUrlData.movieUrl)) {\n              movieUrls.push(movieUrlData);\n              console.log(`\u2705 Added movie URL: ${movieTitle}`);\n              \n              if (movieUrls.length >= maxResults) {\n                console.log(`\ud83c\udfaf Reached max results limit: ${maxResults}`);\n                break;\n              }\n            }\n          }\n          \n        } catch (e) {\n          continue;\n        }\n      }\n      \n      if (movieUrls.length >= maxResults) break;\n      \n    } catch (e) {\n      console.log(`\u274c Error processing film element ${i + 1}: ${e.message}`);\n      continue;\n    }\n  }\n  \n  console.log(`\ud83c\udfaf FIXED: Found ${movieUrls.length} movie URLs for processing`);\n  \n} catch (error) {\n  console.error(`\u274c URL extraction error: ${error.message}`);\n}\n\n// Return each movie URL as a separate item for parallel processing\nreturn movieUrls.map(urlData => ({ json: urlData }));"
      },
      "id": "extract-movie-urls",
      "name": "Extract Movie URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.microserviceUrl }}/extract?url={{ encodeURIComponent($json.movieUrl) }}&title={{ encodeURIComponent($json.title) }}",
        "options": {
          "timeout": 45000
        }
      },
      "id": "call-microservice",
      "name": "Call Playwright Microservice",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1120,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process microservice response and create final movie data\nconst input = $input.first().json;\nconst originalData = input.movieUrl ? input : $input.first().json; // Handle different response structures\nconst microserviceResponse = input.url ? input : (input.data || input);\n\nconsole.log(`\ud83c\udfac Processing microservice response for: ${originalData.title || 'Unknown'}`);\n\n// Extract data from microservice response\nconst streamingUrl = microserviceResponse.streaming_url || microserviceResponse.url;\nconst moviePageUrl = microserviceResponse.movie_page || originalData.movieUrl;\nconst success = microserviceResponse.success;\nconst metadata = microserviceResponse.metadata || {};\n\nconsole.log(`    \ud83d\udd17 Streaming URL: ${streamingUrl}`);\nconsole.log(`    \u2705 Success: ${success}`);\n\n// Create final movie data\nconst movieData = {\n  title: originalData.title || microserviceResponse.title || 'Unknown Movie',\n  url: streamingUrl || moviePageUrl, // Use streaming URL or fallback to movie page\n  movie_page: moviePageUrl,\n  poster: originalData.poster || `https://picsum.photos/300/450?random=${originalData.index || 1}`,\n  year: originalData.year || metadata.year || 'N/A',\n  language: metadata.language || 'Unknown',\n  quality: 'Unknown',\n  genre: 'Unknown',\n  rating: 'N/A',\n  source: '5movierulz-n8n-microservice',\n  data_source: 'n8n',\n  extraction_method: 'microservice_playwright',\n  microservice_success: success,\n  has_streaming_url: !!microserviceResponse.streaming_url\n};\n\nconsole.log(`\u2705 Final movie data: ${movieData.title} - ${movieData.has_streaming_url ? 'HAS STREAMING URL' : 'MOVIE PAGE ONLY'}`);\n\nreturn [{ json: movieData }];"
      },
      "id": "process-response",
      "name": "Process Microservice Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Combine all movie results into final response\nconst allMovies = $input.all();\nconst query = allMovies[0]?.json?.query || $('Input Config').first().json.query;\n\nconsole.log(`\ud83d\udd04 Combining ${allMovies.length} microservice results`);\n\nconst movieResults = allMovies.map(item => item.json).filter(movie => movie.title);\n\n// Count successful streaming URL extractions\nconst streamingUrlCount = movieResults.filter(movie => movie.has_streaming_url).length;\nconst moviePageCount = movieResults.filter(movie => !movie.has_streaming_url).length;\n\nconsole.log(`\u2705 Final results: ${movieResults.length} movies`);\nconsole.log(`    \ud83c\udfac ${streamingUrlCount} with streaming URLs`);\nconsole.log(`    \ud83d\udcc4 ${moviePageCount} with movie page URLs`);\n\n// Create final response\nconst finalResponse = {\n  query: query,\n  results: movieResults,\n  count: movieResults.length,\n  method: 'microservice_playwright_scraping',\n  timestamp: new Date().toISOString(),\n  processing: {\n    total_pages_fetched: allMovies.length,\n    successful_extractions: movieResults.length,\n    streaming_urls_found: streamingUrlCount,\n    movie_pages_only: moviePageCount,\n    extraction_method: 'playwright_microservice'\n  }\n};\n\nreturn [{ json: finalResponse }];"
      },
      "id": "combine-results",
      "name": "Combine Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "webhook-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1780,
        300
      ]
    }
  ],
  "connections": {
    "Movie Search Webhook": {
      "main": [
        [
          {
            "node": "Input Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Config": {
      "main": [
        [
          {
            "node": "Fetch Search Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Search Page": {
      "main": [
        [
          {
            "node": "Extract Movie URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Movie URLs": {
      "main": [
        [
          {
            "node": "Call Playwright Microservice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Playwright Microservice": {
      "main": [
        [
          {
            "node": "Process Microservice Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Microservice Response": {
      "main": [
        [
          {
            "node": "Combine Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Results": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T20:00:00.000Z",
  "versionId": "microservice-v1.2-fixed"
}